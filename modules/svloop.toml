[module]
name = "svloop"
type = "feature"
info = "SVCB Alias Loops"
short = "SVCB loop alias generator"
category = "Alias loops"
records = "SVCB"
tags = "Domain Lock-Up, Denial of Service"
rfc = "RFC9460, RFC8552, RFC8553"
desc = '''
This module implements **alias loops** using **SVCB (Service Binding)** records. The loops can be a **direct loop**, where the alias points back to the **same domain name** as in the original query, or they can include **multiple elements**, cycling through a specified number of domains.

The idea is that if the client/resolver decides to resolve this further, it will enter an **infinite loop**. In practice, however, most modern resolvers detect such loops and terminate the resolution.

Note that SVCB records include a SvcPriority field. In this module, the field always set to 0.

Additionally, the module supports DNS queries for locating different services using the underscore (_) prefix notation, also known as Attrleaf naming pattern, service labels, or underscore labels ([RFC8552](https://datatracker.ietf.org/doc/rfc8552/), [RFC8553](https://datatracker.ietf.org/doc/rfc8553/)).

Note that this feature provides the same functionality as requesting a SVCB record for the generic [loop] feature.

:warning:**BEWARE**:warning:This can potentially lead to a domain lock-up (DoS).
'''
format = '''
**`svloop.<NUMBER>.yourdomain.com`**

Where:

- The **`<NUMBER>`** parameter specifies the number of elements the loop should contain.
'''
seealso = "svalias, svchain, cnloop, dnloop, htloop, loop, mxloop, nptenumloop, nsloop, ptrloop1, ptrloop2, spfloop, srloop, svloop"

[[module.example]]
description = "In this example, we can see a direct loop formed by requesting an SVCB record containing the exact same domain name:"
command = "dig svloop.yourdomain.com @127.0.0.1"

[[module.example]]
description = "In this example, we request a SVCB alias loop consisting of 5 elements:"
command = "dig svloop.5.yourdomain.com @127.0.0.1"
append = "The resulting domain name `svloop.5.1.yourdomain.com` represents the 1st element of the loop."

[[module.example]]
description = "By resolving the 1st element, we are pointed to the 2nd element of the loop:"
command = "dig svloop.5.1.yourdomain.com @127.0.0.1"
append = "This continues up to the 5th and final element - `svloop.5.5.yourdomain.com`."

[[module.example]]
description = "By resolving the final element of the loop, we are directed back to the 1st element again:"
command = "dig svloop.5.5.yourdomain.com @127.0.0.1"
append = "We can see that we are indeed pointed back to the 1st element again, effectively forming a loop."

[[module.example]]
description = "As mentioned in the description, this module also supports DNS queries for locating different services using the underscore (_) prefix notation. This example demonstrates such usage, where we search for an HTTP service specifically designed for mobile devices and running over TCP. In this case, we request a loop of 10 elements:"
command = "dig _mobile._http._tcp.svloop.10.yourdomain.com @127.0.0.1"
append = "The resulting domain name `_mobile._http._tcp.svloop.10.1.yourdomain.com` represents the 1st element of the loop."

[module.code]
python = '''
if req.first_subdomain.startswith("svloop"):
   # Do an alias loop in a SVCB record (SvcPriority 0).
   if req.subdomains[1].isnumeric() and req.subdomains[2].isnumeric():
      # we are already in a loop, e.g.:
      # svloop.10.4.yourdomain.com
      max = int(req.subdomains[1])
      cur = int(req.subdomains[2])
      if cur >= max:
         # go back to the beginning of the loop
         new_domain_name = req.subdomains[0] + "." + str(max) + ".1"
      else:
         # increment the current index
         new_domain_name = req.subdomains[0] + "." + str(max) + "." + str(cur+1)
      for i in range(len(req.subdomains)-3):
         new_domain_name += "." + req.subdomains[i+3]
   elif req.subdomains[1].isnumeric():
      # we are in beginning of a loop with a requested max value, e.g.:
      # svloop.10.yourdomain.com
      max = int(req.subdomains[1])
      if max < 1:
         max = 1
      new_domain_name = req.subdomains[0] + "." + str(max) + "." + "1"
      for i in range(len(req.subdomains)-2):
         new_domain_name += "." + req.subdomains[i+2]
   else:
      # just immediate loop
      new_domain_name = req.full_domain
   ### DNS header ########
   buffer = prep_dns_header(b'\x84\x00', req.QURR, 1, 0, 0)
   ### QUESTION SECTION ########
   if resp.noq: buffer += convDom2Bin(req.full_domain) + req.type_bin + req.class_bin
   ### ANSWER SECTION ########
   data_len = 2+len(convDom2Bin(new_domain_name)) # SvcPriority (2 bytes) + the target name
   buffer += b'\xc0\x0c' if resp.compress else convDom2Bin(req.full_domain)
   buffer += getTypeBin("SVCB") + getClassBin("IN")
   buffer += struct.pack(">L", resp.TTL)      ## TTL
   buffer += struct.pack(">H", data_len)      ## Data length
   buffer += struct.pack(">H", 0)             ## SvcPriority (0 means alias mode - RFC 9460)
   buffer += convDom2Bin(new_domain_name)     ## TargetName
   # log and send
   log("SVCB LOOP %s" % (new_domain_name))
   send_buf(self, buffer)
   #####################################################################
elif req.subdomains[0][0:1] == "_" and (req.subdomains_lc[1].startswith("svloop") or req.subdomains_lc[2].startswith("svloop") or (len(req.subdomains_lc) > 3 and req.subdomains_lc[3].startswith("svloop"))):
   # Do an alias loop in a SVCB record (SvcPriority 0) for any domain name with attribute leaves
   # (domains prefixed with an underscore), up to 3 levels e.g., '_sub._service._proto.svloop...'

   offset=1        # _a.svloop.10.yourdomain.com
   if req.subdomains_lc[2].startswith("svloop"):
      offset = 2   # _a._b.svloop.10.yourdomain.com
   elif req.subdomains_lc[3].startswith("svloop"):
      offset = 3   # _a._b._c.svloop.10.yourdomain.com

   new_domain_name = ""
   for i in range(offset+1):
      new_domain_name += req.subdomains[i] + "."

   if req.subdomains[offset+1].isnumeric() and req.subdomains[offset+2].isnumeric():
      # we are already in a loop, e.g.:
      # _abc.svloop.10.4.yourdomain.com
      max = int(req.subdomains[offset+1])
      cur = int(req.subdomains[offset+2])
      if cur >= max:
         # go back to the beginning of the loop
         new_domain_name += str(max) + ".1"
      else:
         # increment the current index
         new_domain_name += str(max) + "." + str(cur+1)
      for i in range(len(req.subdomains)-3-offset):
         new_domain_name += "." + req.subdomains[i+3+offset]
   elif req.subdomains[offset+1].isnumeric():
      # we are in the beginning of a loop with a requested max value, e.g.:
      # _abc.svloop.10.yourdomain.com
      max = int(req.subdomains[offset+1])
      if max < 1:
         max = 1
      new_domain_name += str(max) + "." + "1"
      for i in range(len(req.subdomains)-2-offset):
         new_domain_name += "." + req.subdomains[i+2+offset]
   else:
      # just immediate loop
      new_domain_name = req.full_domain

   ### DNS header ########
   buffer = prep_dns_header(b'\x84\x00', req.QURR, 1, 0, 0)
   ### QUESTION SECTION ########
   if resp.noq: buffer += convDom2Bin(req.full_domain) + req.type_bin + req.class_bin
   ### ANSWER SECTION ########
   data_len = 2+len(convDom2Bin(new_domain_name)) # SvcPriority (2 bytes) + the target name
   buffer += b'\xc0\x0c' if resp.compress else convDom2Bin(req.full_domain)
   buffer += getTypeBin("SVCB") + getClassBin("IN")
   buffer += struct.pack(">L", resp.TTL)      ## TTL
   buffer += struct.pack(">H", data_len)      ## Data length
   buffer += struct.pack(">H", 0)             ## SvcPriority (0 means alias mode - RFC 9460)
   buffer += convDom2Bin(new_domain_name)     ## TargetName
   # log and send
   log("SVCB LOOP %s" % (new_domain_name))
   send_buf(self, buffer)
   #####################################################################
'''
